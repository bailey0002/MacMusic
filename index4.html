
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stratum MelodyLab — Reference-Aware v4.1</title>
<style>
  :root{
    --bg0:#0e1014; --bg1:#12151b; --bg2:#161b23; --edge:#1f2633;
    --text:#eaf0ff; --muted:#9fb0c8; --accent:#2ed0ff; --ok:#12d87f; --warn:#ffd166;
    --radius:14px; --shadow: 0 6px 20px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  body{margin:0;background:linear-gradient(180deg,var(--bg0),var(--bg1));color:var(--text)}
  header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));
          backdrop-filter:blur(12px);border-bottom:1px solid var(--edge);padding:12px 16px}
  h1{font-size:18px;margin:0;letter-spacing:.3px}
  .wrap{padding:16px;display:grid;gap:16px;max-width:1100px;margin:auto}
  .card{background:linear-gradient(180deg,var(--bg2),var(--bg1));border:1px solid var(--edge);border-radius:var(--radius);
        box-shadow:var(--shadow);padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .col{display:flex;flex-direction:column;gap:8px}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:160px}
  select, input[type="number"], input[type="text"]{
    background:#0b0e13;border:1px solid var(--edge);color:var(--text);
    padding:8px 10px;border-radius:10px;outline:none;min-width:120px;
  }
  input[type="file"]{color:var(--muted); font-size:12px}
  button{background:linear-gradient(180deg,#16202b,#111823);border:1px solid var(--edge);color:var(--text);
         padding:10px 14px;border-radius:12px;cursor:pointer;box-shadow:var(--shadow);
         transition:transform .06s ease, box-shadow .2s ease, border-color .2s, background .2s, color .2s}
  button:hover{transform:translateY(-1px);border-color:#2a3547}
  button.primary{border-color:var(--accent);}
  button.busy{background:#0b1b24; border-color:#164a5a; color:#8fe9ff}
  button.okflash{background:#132116; border-color:#204a2a; color:#bdf6d2}
  button:disabled{opacity:.6; cursor:not-allowed}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
  .track{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:10px;border:1px solid var(--edge);
         border-radius:12px;background:#0b0f16}
  .meter{height:6px;background:#0b0e13;border:1px solid var(--edge);border-radius:6px;overflow:hidden}
  .meter>div{height:100%;background:var(--accent);width:0%}
  .small{font-size:12px;color:var(--muted)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .vis{height:80px;background:#0b0e13;border:1px solid var(--edge);border-radius:10px;position:relative;overflow:hidden}
  .bar{position:absolute;bottom:0;width:4px;background:var(--accent);opacity:.85}
  .status{padding:6px 10px;border-radius:8px;border:1px solid var(--edge); background:#0b0e13; font-size:12px; color:var(--muted)}
  .status.ok{color:var(--ok);border-color:#2a6048}
  .status.warn{color:var(--warn);border-color:#5d4b25}
  .status.busy{color:#2ed0ff;border-color:#214356}
  .chip{display:inline-block;padding:4px 8px;border:1px solid var(--edge);border-radius:999px;margin-right:6px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header><h1>Stratum MelodyLab — Reference-Aware v4.1</h1></header>

<div class="wrap">
  <div class="card">
    <div class="row">
      <button id="startBtn" class="primary">Start Audio (iOS)</button>
      <span id="status" class="status warn">audio locked</span>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Reference (local file)</label>
        <input id="refFile" type="file" accept="audio/*,.mp3,.m4a,.wav,.aif,.aiff" />
        <div class="small">Use MP3/M4A/WAV from the Files app (not Music/Apple Music).</div>
      </div>

      <div class="col" style="min-width:260px">
        <label>Reference (URL, same site / CORS-allowed)</label>
        <div class="row">
          <input id="refUrl" type="text" placeholder="e.g. assets/demo1.mp3" style="min-width:200px" />
          <button id="loadUrlBtn">Load URL</button>
        </div>
      </div>

      <div class="col">
        <label>Demo Tracks</label>
        <div class="row">
          <select id="demoSel">
            <option value="">— choose —</option>
            <option value="assets/demo1.mp3">Demo 1</option>
            <option value="assets/demo2.mp3">Demo 2</option>
            <option value="assets/demo3.wav">Demo 3</option>
          </select>
          <button id="loadDemoBtn">Load Demo</button>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Detected BPM</label>
        <div class="row">
          <input id="bpm" type="number" value="110" min="60" max="180" step="1" />
          <button id="analyzeBtn">Analyze Reference</button>
        </div>
        <div class="small">BPM from autocorrelation (approximate).</div>
      </div>
      <div class="col">
        <label>Detected Key</label>
        <div class="row">
          <input id="detectedKey" type="text" value="(none)" readonly />
          <button id="detectKeyBtn">Detect Key</button>
        </div>
        <div class="small">Krumhansl key profile from chroma.</div>
      </div>
      <div class="col">
        <label>Use reference chords</label>
        <div class="row">
          <input id="useRefChords" type="checkbox" disabled />
          <span class="small">One triad per bar after detection</span>
        </div>
      </div>
      <div class="col">
        <label>Length (bars)</label>
        <input id="bars" type="number" value="32" min="8" max="96" step="4" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="genBtn" class="primary">Generate Song</button>
      <span id="genChip" class="chip">idle</span>
      <button id="playBtn">Play</button>
      <button id="stopBtn">Stop</button>
      <button id="exportBtn">Export WAV</button>
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div>
        <div class="small">Arrangement preview</div>
        <div id="arrangement" class="mono small">—</div>
        <div class="small" id="chordPreview"></div>
      </div>
      <div class="row">
        <button class="ghost" id="regenDrums">Regenerate Drums</button>
        <button class="ghost" id="regenLead">Regenerate Lead</button>
      </div>
    </div>
    <div class="vis" id="visualizer"></div>
  </div>

  <div class="card">
    <div class="grid" id="tracks"></div>
  </div>

  <div class="card small">
    <b>Status:</b> <span id="flowStatus" class="status">idle</span><br/><br/>
    <b>Notes</b><br/>
    • Reference features are computed on-device; chords are coarse (one per bar). Works best on harmonic pop/EDM.<br/>
    • Still a synth sketch; no stem separation.
  </div>
</div>

<script>
(() => {
  let audioCtx = null, started = false, refBuffer = null, analyser = null, currentGraph = null, schedule = null, visRAF=null;
  const q = (s)=>document.querySelector(s);
  const statusEl = q('#status'), flowEl = q('#flowStatus'), bpmEl = q('#bpm'), vis = q('#visualizer'), tracksEl = q('#tracks'), arrangementEl = q('#arrangement');
  const chordPreviewEl = q('#chordPreview'), genBtn = q('#genBtn'), genChip = q('#genChip'), useRefChordsEl = q('#useRefChords');

  function setStatus(msg, cls=''){ statusEl.textContent = msg; statusEl.className='status '+cls; }
  function setFlow(msg, cls=''){ flowEl.textContent = msg; flowEl.className='status '+cls; }
  function setGenState(state){ // idle | generating | ready
    if(state==='generating'){ genBtn.classList.add('busy'); genBtn.textContent='Generating…'; genChip.textContent='generating'; }
    else if(state==='ready'){ genBtn.classList.remove('busy'); genBtn.classList.add('okflash'); setTimeout(()=>genBtn.classList.remove('okflash'), 800); genBtn.textContent='Generate Song'; genChip.textContent='ready'; }
    else { genBtn.classList.remove('busy'); genBtn.textContent='Generate Song'; genChip.textContent='idle'; }
  }

  async function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser(); analyser.fftSize=2048;
    }
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){} }
  }
  function initUIAudioReady(){ started = true; setStatus('ready', 'ok'); }

  // --- Loaders ---
  q('#refFile').addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if(!f){ return; }
    try {
      const ab = await f.arrayBuffer();
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      refBuffer = await ctx.decodeAudioData(ab.slice(0)); ctx.close();
      setFlow(`Loaded file: ${f.name}`, 'ok');
    } catch(err){ console.error(err); setFlow('Could not decode that file.', 'warn'); }
  });
  async function loadFromURL(url){
    try {
      setFlow('Fetching…','busy');
      const res = await fetch(url, {mode:'cors'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const ab = await res.arrayBuffer();
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      refBuffer = await ctx.decodeAudioData(ab.slice(0)); ctx.close();
      setFlow(`Loaded URL: ${url}`, 'ok');
    } catch(err){ console.error(err); setFlow('Could not fetch/decode URL. Check path and CORS.', 'warn'); }
  }
  q('#loadUrlBtn').addEventListener('click', ()=>{ const url=q('#refUrl').value.trim(); if(url) loadFromURL(url); });
  q('#loadDemoBtn').addEventListener('click', ()=>{ const url=q('#demoSel').value; if(url) loadFromURL(url); });

  // ---------- Feature extraction utilities ----------
  function mixToMono(buf){ const len=buf.length, sr=buf.sampleRate, outBuf = new AudioBuffer({length:len,sampleRate:sr,numberOfChannels:1});
    const out=outBuf.getChannelData(0), chans=[]; for(let c=0;c<buf.numberOfChannels;c++) chans.push(buf.getChannelData(c));
    for(let i=0;i<len;i++){ let s=0; for(let c=0;c<chans.length;c++) s+=chans[c][i]; out[i]=s/chans.length; } return outBuf;}
  function centerSlice(buf, seconds){ const sr=buf.sampleRate, len=Math.min(buf.length, Math.floor(seconds*sr)), start=Math.max(0, Math.floor((buf.length-len)/2));
    const out=new AudioBuffer({length:len, sampleRate:sr, numberOfChannels:1}); out.copyToChannel(buf.getChannelData(0).slice(start,start+len),0,0); return out; }
  function downsample(buf, fromSR, toSR){ if(buf.sampleRate!==fromSR) fromSR=buf.sampleRate; const ratio=fromSR/toSR; const src=buf.getChannelData(0);
    const len=Math.floor(src.length/ratio); const outBuf=new AudioBuffer({length:len, sampleRate:toSR, numberOfChannels:1}); const out=outBuf.getChannelData(0);
    let acc=0,cnt=0,idx=0; for(let i=0;i<src.length;i++){ acc+=src[i]; cnt++; if(cnt>=ratio){ out[idx++]=acc/cnt; acc=0; cnt=0; } } return outBuf; }
  function preEmphasis(buf,a=0.97){ const src=buf.getChannelData(0); const outBuf=new AudioBuffer({length:src.length, sampleRate:buf.sampleRate, numberOfChannels:1});
    const out=outBuf.getChannelData(0); out[0]=src[0]; for(let i=1;i<src.length;i++) out[i]=src[i]-a*src[i-1]; return outBuf; }
  function amplitudeEnvelope(buf, win=1024, hop=512){ const x=buf.getChannelData(0); const frames=Math.floor((x.length-win)/hop)+1; const env=new Float32Array(frames);
    for(let f=0; f<frames; f++){ let sum=0; const start=f*hop; for(let i=0;i<win;i++){ const s=x[start+i]; sum+=s*s; } env[f]=Math.sqrt(sum/win); }
    let max=1e-9; for(let i=0;i<env.length;i++) if(env[i]>max) max=env[i]; for(let i=0;i<env.length;i++) env[i]/=max; return env; }
  function estimateBPM(env, fps){ const n=env.length,minBPM=60,maxBPM=180,minLag=Math.floor(fps*60/maxBPM),maxLag=Math.floor(fps*60/minBPM);
    let bestLag=minLag,best=-Infinity; for(let lag=minLag;lag<=maxLag;lag++){ let sum=0; for(let i=0;i<n-lag;i++){ sum+=env[i]*env[i+lag]; } if(sum>best){ best=sum; bestLag=lag; } }
    let bpm=60*fps/bestLag; if(bpm<75) bpm*=2; if(bpm>165) bpm/=2; return bpm; }

  // --- Faster chroma ---
  function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++){ w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); } return w; }
  function stftChroma(buf, winSize=2048, hop=1024){
    const sr=buf.sampleRate; const x=buf.getChannelData(0);
    const N=winSize; const H=hop; const numFrames = Math.max(1, Math.floor((x.length-N)/H)+1);
    const W = hann(N);
    function dftMag(frame){
      const M=N/2;
      const mags=new Float32Array(M);
      for(let k=0;k<M;k++){
        let re=0, im=0;
        for(let n=0;n<N;n++){
          const ang = -2*Math.PI*k*n/N;
          const s = x[frame*H+n]*W[n];
          re += s*Math.cos(ang);
          im += s*Math.sin(ang);
        }
        mags[k]=Math.sqrt(re*re+im*im);
      }
      return mags;
    }
    const chromaFrames=[];
    for(let f=0; f<numFrames; f++){
      const mags=dftMag(f);
      const chroma=new Float32Array(12);
      for(let k=1;k<mags.length;k++){
        const freq = k*sr/N;
        const midi = Math.round(69+12*Math.log2(freq/440));
        if (!isFinite(midi)) continue;
        const pc = ((midi%12)+12)%12;
        chroma[pc] += mags[k];
      }
      let s=0; for(let i=0;i<12;i++) s+=chroma[i];
      if(s>0){ for(let i=0;i<12;i++) chroma[i]/=s; }
      chromaFrames.push(chroma);
    }
    return {frames: chromaFrames, sr, hop: H/sr};
  }

  const keyProfiles = {
    major: [6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88],
    minor: [6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17]
  };
  const noteNames=["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
  function rotate(arr, n){ const a=arr.slice(); while(n-->0){ a.push(a.shift()); } return a; }
  function detectKeyFromChromaAvg(chromaAvg){
    let best = {mode:'major', root:0, score:-1};
    ['major','minor'].forEach(mode=>{
      for(let r=0;r<12;r++){
        const prof = rotate(keyProfiles[mode], r);
        const sum = prof.reduce((a,c)=>a+c,0);
        const p = prof.map(v=>v/sum);
        let dotv=0, na=0, nb=0;
        for(let i=0;i<12;i++){ dotv+=chromaAvg[i]*p[i]; na+=chromaAvg[i]*chromaAvg[i]; nb+=p[i]*p[i]; }
        const sc = dotv/(Math.sqrt(na*nb)+1e-9);
        if(sc>best.score) best={mode, root:r, score:sc};
      }
    });
    return best;
  }

  const triads = {major:[0,4,7], minor:[0,3,7], dim:[0,3,6]};
  function chordName(rootPc, quality){ const name=noteNames[rootPc]; const qual=quality==='major'?'':quality==='minor'?'m':'dim'; return name+qual; }
  function estimateChords(chromaFrames, secondsPerFrame, bpm, totalBars){
    const spb = 60/(bpm||120);
    const secPerBar = 4*spb;
    const framesPerBar = Math.max(1, Math.round(secPerBar/secondsPerFrame));
    const bars = Math.min(totalBars, Math.floor(chromaFrames.length/framesPerBar));
    const chords=[];
    for(let b=0;b<bars;b++){
      const acc=new Float32Array(12);
      for(let f=0; f<framesPerBar; f++){
        const fr = chromaFrames[b*framesPerBar+f];
        for(let i=0;i<12;i++) acc[i]+=fr[i];
      }
      let best={root:0, qual:'major', score:-1};
      for(let root=0; root<12; root++){
        ['major','minor','dim'].forEach(qual=>{
          const pcs = triads[qual].map(semi => (semi+root)%12);
          let s=0; pcs.forEach(pc => s+=acc[pc]);
          if(s>best.score) best={root, qual, score:s};
        });
      }
      chords.push({root:best.root, quality:best.qual, name:chordName(best.root, best.qual)});
    }
    return chords;
  }

  // ---------- BPM Analysis ----------
  q('#analyzeBtn').addEventListener('click', async ()=>{
    try{
      if(!refBuffer){ setFlow('Load a reference first (File/URL/Demo).','warn'); return; }
      setFlow('Analyzing BPM…','busy'); const ch = refBuffer.numberOfChannels>1 ? mixToMono(refBuffer) : refBuffer;
      const slice = centerSlice(ch, Math.min(30, ch.duration)); const down = downsample(slice, 44100, 11025);
      const pre = preEmphasis(down, 0.97); const env = amplitudeEnvelope(pre, 1024, 512);
      const bpm = estimateBPM(env, 11025/512); bpmEl.value = Math.round(bpm); setFlow(`Detected BPM ~${Math.round(bpm)}`,'ok');
    }catch(e){ console.error(e); setFlow('BPM analysis failed','warn'); }
  });

  q('#detectKeyBtn').addEventListener('click', async ()=>{
    try{
      if(!refBuffer){ setFlow('Load a reference first.','warn'); return; }
      setFlow('Analyzing key & chords…','busy');
      const ch = refBuffer.numberOfChannels>1 ? mixToMono(refBuffer) : refBuffer;
      const slice = centerSlice(ch, Math.min(35, ch.duration));
      const chroma = stftChroma(slice, 2048, 1024);
      const avg = new Float32Array(12);
      chroma.frames.forEach(fr => { for(let i=0;i<12;i++) avg[i]+=fr[i]; });
      let s=0; for(let i=0;i<12;i++) s+=avg[i]; if(s>0) for(let i=0;i<12;i++) avg[i]/=s;
      const key = detectKeyFromChromaAvg(avg);
      const keyText = `${['C','C#','D','Eb','E','F','F#','G','Ab','A','Bb','B'][key.root]} ${key.mode}`;
      q('#detectedKey').value = keyText;
      const bpm = parseFloat(bpmEl.value)||110;
      const estChords = estimateChords(chroma.frames, chroma.hop, bpm, parseInt(q('#bars').value)||32);
      chordPreviewEl.textContent = estChords.map(c=>c.name).join(' | ');
      window.__REF_FEATURES__ = {key, estChords};
      useRefChordsEl.disabled = false;
      useRefChordsEl.checked = true;
      setFlow('Key & chords ready','ok');
    }catch(e){ console.error(e); setFlow('Key/chord detection failed','warn'); }
  });

  // ---------- Generator ----------
  function noteToFreq(n){ return 440*Math.pow(2,(n-69)/12); }
  function midiForPc(pc, octave=4){ return 12*(octave+1)+pc; }
  const noteNamesArr=["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];

  function buildChordsFromRef(estChords){
    return estChords.map(c=>{
      const pcs = c.quality==='major'? [0,4,7] : c.quality==='minor'? [0,3,7] : [0,3,6];
      const notes = pcs.map(semi => midiForPc((c.root+semi)%12, 4));
      return {name:c.name, notes};
    });
  }
  function defaultProgression(keyMode){
    const keyRoot = keyMode?.root ?? 0;
    const mode = keyMode?.mode ?? 'minor';
    const degrees = mode==='major'?[0,2,4,5,7,9,11]:[0,2,3,5,7,8,10];
    const progIdx = [[0,5,3,4],[0,4,5,3]][ mode==='major'?0:1 ];
    return progIdx.map(di => {
      const rootPc = (degrees[di] + keyRoot) % 12;
      const quality = (mode==='major' && (di===0||di===3||di===4)) || (mode!=='major' && (di===2)) ? 'major' : 'minor';
      const pcs = quality==='major'? [0,4,7] : [0,3,7];
      const notes = pcs.map(semi => midiForPc((rootPc+semi)%12, 4));
      const name = chordName(rootPc, quality);
      return {name, notes};
    });
  }

  function generateSong(){
    setGenState('generating');
    setFlow('Generating…','busy');
    const bpm=parseFloat(bpmEl.value)||110, bars=Math.max(4, Math.min(96, parseInt(q('#bars').value)||32));
    const spb=60/bpm, spbar=spb*4;
    let chordsTimeline=[];
    const ref = window.__REF_FEATURES__;
    if (useRefChordsEl.checked && ref?.estChords?.length){
      const perBar = buildChordsFromRef(ref.estChords).slice(0, bars);
      for(let i=0;i<bars;i++){ const c=perBar[i%perBar.length]; chordsTimeline.push({time:i*spbar, notes:c.notes, name:c.name}); }
    } else {
      const base = defaultProgression(ref?.key);
      for(let i=0;i<bars;i++){ const c=base[i%base.length]; chordsTimeline.push({time:i*spbar, notes:c.notes, name:c.name}); }
    }
    chordPreviewEl.textContent = chordsTimeline.map(c=>c.name).join(' | ');

    const bass=[], arp=[], lead=[], pad=[], drums=[];
    chordsTimeline.forEach((ch, idx)=>{
      const root = ch.notes[0]-24;
      bass.push({time:ch.time, midi:root, dur:spb*1.0, vel:.95});
      bass.push({time:ch.time+2*spb, midi:root, dur:spb*1.0, vel:.9});
      const seq=[0,1,2,1];
      for(let s=0;s<16;s++){ const tone=ch.notes[ seq[s%seq.length] ]; arp.push({time:ch.time + s*(spb/4), midi:tone+12, dur:spb/4*0.9, vel:.35}); }
      const target = ch.notes[ (idx%3) ] + 12;
      lead.push({time:ch.time, midi:target, dur:spb*0.95, vel:.75});
      lead.push({time:ch.time+spb, midi:target+2, dur:spb*0.9, vel:.7});
      pad.push({time:ch.time, notes:ch.notes.map(n=>n+12), dur:spbar, vel:.28});
      const swing=0.54; drums.push({time:ch.time, type:'kick'}); drums.push({time:ch.time+2*spb, type:'kick'}); drums.push({time:ch.time+1*spb, type:'snare'}); drums.push({time:ch.time+3*spb, type:'snare'});
      for(let e=0;e<8;e++){ const off=(e%2===1)?(spb/2)*(2*swing-1):0; drums.push({time:ch.time + e*(spb/2) + off, type:'hat'}); }
    });

    schedule={bpm,bars,chordsTimeline,bass,arp,lead,pad,drums,lengthSec: chordsTimeline.length*spbar};
    arrangementEl.textContent = `Bars: ${bars}   @ ${Math.round(bpm)} BPM`;
    drawVisSkeleton(chordsTimeline.length*4);
    buildTrackUI();
    setFlow('Ready','ok');
    setGenState('ready');
  }

  function drawVisSkeleton(steps){ vis.innerHTML=''; const width=vis.clientWidth; const stepW=Math.max(2, Math.floor(width/steps));
    for(let i=0;i<steps;i++){ const bar=document.createElement('div'); bar.className='bar'; bar.style.left=(i*stepW)+'px'; bar.style.width=(stepW-1)+'px'; bar.style.height=(10+(i%4)*6)+'px'; bar.style.opacity=0.25+0.1*(i%4); vis.appendChild(bar);} }
  function buildTrackUI(){ tracksEl.innerHTML=''; const parts=[{id:'drums',name:'Drums'},{id:'bass',name:'Bass'},{id:'chords',name:'Chords'},{id:'arp',name:'Arp'},{id:'lead',name:'Lead'},{id:'pad',name:'Pad'}];
    parts.forEach(p=>{ const div=document.createElement('div'); div.className='track'; div.innerHTML=`
      <div><div>${p.name}</div><div class="small">Mute <input type="checkbox" id="mute_${p.id}" /></div></div>
      <div style="flex:1;margin:0 10px" class="meter"><div id="vu_${p.id}"></div></div>
      <div><label>Vol</label><input type="range" min="0" max="1" step="0.01" value="${p.id==='drums'?1.0:p.id==='lead'?0.9:0.85}" id="vol_${p.id}" /></div>`; tracksEl.appendChild(div); }); }

  // ---------- Playback chain ----------
  function createFXBus(){
    const mix = audioCtx.createGain(); mix.gain.value = 1.0;
    const master = audioCtx.createGain(); master.gain.value = 0.95;
    const comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -20; comp.knee.value = 20; comp.ratio.value = 3.5; comp.attack.value = 0.005; comp.release.value = 0.25;
    mix.connect(comp).connect(master).connect(analyser).connect(audioCtx.destination);
    return {in:mix, out:master};
  }

  function playSong(){
    if(!schedule){ generateSong(); }
    stopSong();
    setFlow('Playing…','busy');
    const startT=audioCtx.currentTime+0.05; const bus=createFXBus();
    const vols={}; ['drums','bass','chords','arp','lead','pad'].forEach(id=>{ const g=audioCtx.createGain(); g.gain.value=parseFloat(q('#vol_'+id).value); g.connect(bus.in); vols[id]=g; });

    schedule.drums.forEach(ev=>{ const t=startT+ev.time; if(q('#mute_drums').checked) return; if(ev.type==='kick') synthKick(t,vols.drums); else if(ev.type==='snare') synthSnare(t,vols.drums); else synthHat(t,vols.drums); });
    schedule.bass.forEach(n=>{ const t=startT+n.time; if(!q('#mute_bass').checked) synthMono(n.midi,n.dur,n.vel,t,vols.bass,'saw',500); });
    schedule.chordsTimeline.forEach(ch=>{ const t=startT+ch.time; if(!q('#mute_chords').checked) ch.notes.forEach((m,j)=> synthPad(m+12, (2.2), 0.22, t, vols.chords, 1800-(j*200))); });
    schedule.arp.forEach(n=>{ const t=startT+n.time; if(!q('#mute_arp').checked) synthMono(n.midi,n.dur,n.vel,t,vols.arp,'triangle',1400); });
    schedule.lead.forEach(n=>{ const t=startT+n.time; if(!q('#mute_lead').checked) synthLead(n.midi,n.dur,n.vel,t,vols.lead); });
    schedule.pad.forEach(p=>{ const t=startT+p.time; if(!q('#mute_pad').checked) p.notes.forEach(m=> synthPad(m,p.dur,p.vel,t,vols.pad,1600)); });

    currentGraph={bus};
    startVis();
    setTimeout(()=>{ stopSong(); setFlow('Stopped',''); }, (schedule.lengthSec+0.2)*1000);
  }

  function stopSong(){ if(currentGraph){ try{ currentGraph.out.disconnect(); }catch(e){} currentGraph=null; } stopVis(); }
  // Synths
  function envParam(g, t, a=0.01, d=0.12, s=0.7, r=0.15, v=0.8){
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(v, t+a);
    g.gain.linearRampToValueAtTime(v*s, t+a+d);
    g.gain.linearRampToValueAtTime(0.0001, t+a+d+r);
  }
  function noteToFreq(n){ return 440*Math.pow(2,(n-69)/12); }
  function synthKick(t,dest){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(150,t); o.frequency.exponentialRampToValueAtTime(42,t+0.12);
    g.gain.setValueAtTime(1,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.22); o.connect(g).connect(dest); o.start(t); o.stop(t+0.24); }
  function synthSnare(t,dest){ const n=audioCtx.createBuffer(1,audioCtx.sampleRate*0.25,audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.6); }
    const s=audioCtx.createBufferSource(); s.buffer=n; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1850; bp.Q.value=0.6; const g=audioCtx.createGain(); envParam(g,t,0.001,0.12,0.0,0.12,0.8);
    s.connect(bp).connect(g).connect(dest); s.start(t); s.stop(t+0.25); }
  function synthHat(t,dest){ const n=audioCtx.createBuffer(1,audioCtx.sampleRate*0.12,audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1); }
    const s=audioCtx.createBufferSource(); s.buffer=n; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=9000; hp.Q.value=0.8; const g=audioCtx.createGain(); envParam(g,t,0.001,0.05,0.0,0.05,0.35);
    s.connect(hp).connect(g).connect(dest); s.start(t); s.stop(t+0.12); }
  function synthMono(midi,dur,vel,t,dest,type='saw',cutoff=1000){
    const o1=audioCtx.createOscillator(); const o2=audioCtx.createOscillator(); o1.type=type; o2.type=type;
    const g=audioCtx.createGain(); const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(cutoff,t);
    o1.frequency.setValueAtTime( noteToFreq(midi)*0.999, t); o2.frequency.setValueAtTime( noteToFreq(midi)*1.001, t);
    envParam(g,t,0.01,0.10,0.6,0.12,vel);
    o1.connect(f); o2.connect(f); f.connect(g).connect(dest);
    o1.start(t); o2.start(t); o1.stop(t+dur+0.2); o2.stop(t+dur+0.2);
  }
  function synthLead(midi,dur,vel,t,dest){
    const o1=audioCtx.createOscillator(); const o2=audioCtx.createOscillator(); o1.type='saw'; o2.type='triangle';
    const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(2200,t);
    const g=audioCtx.createGain(); envParam(g,t,0.008,0.12,0.55,0.12,vel);
    o1.frequency.setValueAtTime(noteToFreq(midi)*0.999,t); o2.frequency.setValueAtTime(noteToFreq(midi)*1.001,t);
    o1.connect(f).connect(g).connect(dest); o2.connect(f);
    o1.start(t); o2.start(t); o1.stop(t+dur+0.2); o2.stop(t+dur+0.2);
  }
  function synthPad(midi,dur,vel,t,dest,cutoff=1600){
    const o=audioCtx.createOscillator(); o.type='saw';
    const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(cutoff,t);
    const g=audioCtx.createGain();
    g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(vel, t+0.35); g.gain.linearRampToValueAtTime(vel*0.85, t+dur*0.8); g.gain.linearRampToValueAtTime(0.0001, t+dur+0.45);
    o.frequency.setValueAtTime(noteToFreq(midi), t);
    o.connect(f).connect(g).connect(dest);
    o.start(t); o.stop(t+dur+0.6);
  }

  // Visualization
  function startVis(){ stopVis(); const arr=new Uint8Array(analyser.frequencyBinCount); function loop(){ analyser.getByteTimeDomainData(arr);
      const bars=vis.children; if(bars.length){ const avg=arr.reduce((a,b)=>a+Math.abs(b-128),0)/arr.length; const h=Math.min(80, Math.max(6, avg*0.9));
      const idx=Math.floor(((audioCtx.currentTime%1)*bars.length)); for(let i=0;i<bars.length;i++){ const el=bars[i]; if(i===idx) el.style.height=h+'px'; el.style.opacity=0.2+0.6*((i%4)/4);} } visRAF=requestAnimationFrame(loop); }
    visRAF=requestAnimationFrame(loop); }
  function stopVis(){ if(visRAF) cancelAnimationFrame(visRAF); visRAF=null; }

  // UI Handlers
  q('#startBtn').addEventListener('click', async ()=>{ await ensureAudio(); initUIAudioReady(); });
  q('#genBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); generateSong(); });
  q('#playBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); playSong(); });
  q('#stopBtn').addEventListener('click', ()=>{ stopSong(); setFlow('Stopped',''); });
  q('#exportBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); exportWav(); });
  q('#regenDrums').addEventListener('click', ()=>{ if(schedule) generateSong(); });
  q('#regenLead').addEventListener('click', ()=>{ if(schedule) generateSong(); });

  // Auto-generate on load
  window.addEventListener('load', ()=>{ generateSong(); });
})();
</script>
</body>
</html>
