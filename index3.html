
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stratum MelodyLab — Reference-Aware v4</title>
<style>
  :root{
    --bg0:#0e1014; --bg1:#12151b; --bg2:#161b23; --edge:#1f2633;
    --text:#eaf0ff; --muted:#9fb0c8; --accent:#2ed0ff; --accent2:#FFF500;
    --radius:14px; --shadow: 0 6px 20px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  body{margin:0;background:linear-gradient(180deg,var(--bg0),var(--bg1));color:var(--text)}
  header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));
          backdrop-filter:blur(12px);border-bottom:1px solid var(--edge);padding:12px 16px}
  h1{font-size:18px;margin:0;letter-spacing:.3px}
  .wrap{padding:16px;display:grid;gap:16px;max-width:1100px;margin:auto}
  .card{background:linear-gradient(180deg,var(--bg2),var(--bg1));border:1px solid var(--edge);border-radius:var(--radius);
        box-shadow:var(--shadow);padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .col{display:flex;flex-direction:column;gap:8px}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:160px}
  select, input[type="number"], input[type="text"]{
    background:#0b0e13;border:1px solid var(--edge);color:var(--text);
    padding:8px 10px;border-radius:10px;outline:none;min-width:120px;
  }
  input[type="file"]{color:var(--muted); font-size:12px}
  button{background:linear-gradient(180deg,#16202b,#111823);border:1px solid var(--edge);color:var(--text);
         padding:10px 14px;border-radius:12px;cursor:pointer;box-shadow:var(--shadow);
         transition:transform .06s ease, box-shadow .2s ease, border-color .2s}
  button:hover{transform:translateY(-1px);border-color:#2a3547}
  button.primary{border-color:var(--accent);}
  button.ghost{background:transparent}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid var(--edge);font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
  .track{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:10px;border:1px solid var(--edge);
         border-radius:12px;background:#0b0f16}
  .meter{height:6px;background:#0b0e13;border:1px solid var(--edge);border-radius:6px;overflow:hidden}
  .meter>div{height:100%;background:var(--accent);width:0%}
  .small{font-size:12px;color:var(--muted)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .vis{height:80px;background:#0b0e13;border:1px solid var(--edge);border-radius:10px;position:relative;overflow:hidden}
  .bar{position:absolute;bottom:0;width:4px;background:var(--accent);opacity:.85}
  .status{padding:6px 10px;border-radius:8px;border:1px solid var(--edge); background:#0b0e13; font-size:12px; color:var(--muted)}
  .status.ok{color:#12d87f;border-color:#2a6048}
  .status.warn{color:#ffd166;border-color:#5d4b25}
  .status.busy{color:#2ed0ff;border-color:#214356}
</style>
</head>
<body>
<header><h1>Stratum MelodyLab — Reference-Aware v4</h1></header>

<div class="wrap">
  <div class="card">
    <div class="row">
      <button id="startBtn" class="primary">Start Audio (iOS)</button>
      <span id="status" class="status warn">audio locked</span>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Reference (local file)</label>
        <input id="refFile" type="file" accept="audio/*,.mp3,.m4a,.wav,.aif,.aiff" />
        <div class="small">Use MP3/M4A/WAV from the Files app (not Music/Apple Music).</div>
      </div>

      <div class="col" style="min-width:260px">
        <label>Reference (URL, same site / CORS-allowed)</label>
        <div class="row">
          <input id="refUrl" type="text" placeholder="e.g. assets/demo1.mp3" style="min-width:200px" />
          <button id="loadUrlBtn">Load URL</button>
        </div>
      </div>

      <div class="col">
        <label>Demo Tracks</label>
        <div class="row">
          <select id="demoSel">
            <option value="">— choose —</option>
            <option value="assets/demo1.mp3">Demo 1</option>
            <option value="assets/demo2.mp3">Demo 2</option>
            <option value="assets/demo3.wav">Demo 3</option>
          </select>
          <button id="loadDemoBtn">Load Demo</button>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Detected BPM</label>
        <div class="row">
          <input id="bpm" type="number" value="110" min="60" max="180" step="1" />
          <button id="analyzeBtn">Analyze Reference</button>
        </div>
        <div class="small">BPM from autocorrelation (approximate).</div>
      </div>
      <div class="col">
        <label>Detected Key</label>
        <div class="row">
          <input id="detectedKey" type="text" value="(none)" readonly />
          <button id="detectKeyBtn">Detect Key</button>
        </div>
        <div class="small">Krumhansl key profile from chroma.</div>
      </div>
      <div class="col">
        <label>Use reference chords</label>
        <div class="row">
          <input id="useRefChords" type="checkbox" />
          <span class="small">Estimates per-bar triads; drives bass/chords/arp/lead</span>
        </div>
      </div>
      <div class="col">
        <label>Length (bars)</label>
        <input id="bars" type="number" value="32" min="8" max="96" step="4" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="genBtn" class="primary">Generate Song</button>
      <button id="playBtn">Play</button>
      <button id="stopBtn">Stop</button>
      <button id="exportBtn">Export WAV</button>
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div>
        <div class="small">Arrangement preview</div>
        <div id="arrangement" class="mono small">—</div>
        <div class="small" id="chordPreview"></div>
      </div>
      <div class="row">
        <button class="ghost" id="regenDrums">Regenerate Drums</button>
        <button class="ghost" id="regenLead">Regenerate Lead</button>
      </div>
    </div>
    <div class="vis" id="visualizer"></div>
  </div>

  <div class="card">
    <div class="grid" id="tracks"></div>
  </div>

  <div class="card small">
    <b>Status:</b> <span id="flowStatus" class="status">idle</span><br/><br/>
    <b>Notes</b><br/>
    • Reference features are computed on-device; chords are coarse (one per bar) and best on harmonic pop/EDM.<br/>
    • This is still a sketcher: subtractive synth voices + light delay/reverb; no stem separation.
  </div>
</div>

<script>
(() => {
  let audioCtx = null, started = false, refBuffer = null, analyser = null, currentGraph = null, schedule = null, visRAF=null;
  const q = (s)=>document.querySelector(s);
  const statusEl = q('#status'), flowEl = q('#flowStatus'), bpmEl = q('#bpm'), vis = q('#visualizer'), tracksEl = q('#tracks'), arrangementEl = q('#arrangement');
  const chordPreviewEl = q('#chordPreview');

  function setStatus(msg, cls=''){ statusEl.textContent = msg; statusEl.className='status '+cls; }
  function setFlow(msg, cls=''){ flowEl.textContent = msg; flowEl.className='status '+cls; }

  async function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser(); analyser.fftSize=2048;
    }
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }

  function initUIAudioReady(){ started = true; setStatus('ready', 'ok'); }

  // --- Loaders ---
  q('#refFile').addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if(!f){ return; }
    try {
      const ab = await f.arrayBuffer();
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      refBuffer = await ctx.decodeAudioData(ab.slice(0)); ctx.close();
      setFlow(`Loaded file: ${f.name}`, 'ok');
    } catch(err){ console.error(err); setFlow('Could not decode that file.', 'warn'); }
  });
  async function loadFromURL(url){
    try {
      setFlow('Fetching…','busy');
      const res = await fetch(url, {mode:'cors'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const ab = await res.arrayBuffer();
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      refBuffer = await ctx.decodeAudioData(ab.slice(0)); ctx.close();
      setFlow(`Loaded URL: ${url}`, 'ok');
    } catch(err){ console.error(err); setFlow('Could not fetch/decode URL. Check path and CORS.', 'warn'); }
  }
  q('#loadUrlBtn').addEventListener('click', ()=>{ const url=q('#refUrl').value.trim(); if(url) loadFromURL(url); });
  q('#loadDemoBtn').addEventListener('click', ()=>{ const url=q('#demoSel').value; if(url) loadFromURL(url); });

  // ---------- Feature extraction utilities ----------
  function mixToMono(buf){ const len=buf.length, sr=buf.sampleRate, outBuf = new AudioBuffer({length:len,sampleRate:sr,numberOfChannels:1});
    const out=outBuf.getChannelData(0), chans=[]; for(let c=0;c<buf.numberOfChannels;c++) chans.push(buf.getChannelData(c));
    for(let i=0;i<len;i++){ let s=0; for(let c=0;c<chans.length;c++) s+=chans[c][i]; out[i]=s/chans.length; } return outBuf;}
  function centerSlice(buf, seconds){ const sr=buf.sampleRate, len=Math.min(buf.length, Math.floor(seconds*sr)), start=Math.max(0, Math.floor((buf.length-len)/2));
    const out=new AudioBuffer({length:len, sampleRate:sr, numberOfChannels:1}); out.copyToChannel(buf.getChannelData(0).slice(start,start+len),0,0); return out; }
  function downsample(buf, fromSR, toSR){ if(buf.sampleRate!==fromSR) fromSR=buf.sampleRate; const ratio=fromSR/toSR; const src=buf.getChannelData(0);
    const len=Math.floor(src.length/ratio); const outBuf=new AudioBuffer({length:len, sampleRate:toSR, numberOfChannels:1}); const out=outBuf.getChannelData(0);
    let acc=0,cnt=0,idx=0; for(let i=0;i<src.length;i++){ acc+=src[i]; cnt++; if(cnt>=ratio){ out[idx++]=acc/cnt; acc=0; cnt=0; } } return outBuf; }
  function preEmphasis(buf,a=0.97){ const src=buf.getChannelData(0); const outBuf=new AudioBuffer({length:src.length, sampleRate:buf.sampleRate, numberOfChannels:1});
    const out=outBuf.getChannelData(0); out[0]=src[0]; for(let i=1;i<src.length;i++) out[i]=src[i]-a*src[i-1]; return outBuf; }
  function amplitudeEnvelope(buf, win=1024, hop=512){ const x=buf.getChannelData(0); const frames=Math.floor((x.length-win)/hop)+1; const env=new Float32Array(frames);
    for(let f=0; f<frames; f++){ let sum=0; const start=f*hop; for(let i=0;i<win;i++){ const s=x[start+i]; sum+=s*s; } env[f]=Math.sqrt(sum/win); }
    let max=1e-9; for(let i=0;i<env.length;i++) if(env[i]>max) max=env[i]; for(let i=0;i<env.length;i++) env[i]/=max; return env; }
  function estimateBPM(env, fps){ const n=env.length,minBPM=60,maxBPM=180,minLag=Math.floor(fps*60/maxBPM),maxLag=Math.floor(fps*60/minBPM);
    let bestLag=minLag,best=-Infinity; for(let lag=minLag;lag<=maxLag;lag++){ let sum=0; for(let i=0;i<n-lag;i++){ sum+=env[i]*env[i+lag]; } if(sum>best){ best=sum; bestLag=lag; } }
    let bpm=60*fps/bestLag; if(bpm<75) bpm*=2; if(bpm>165) bpm/=2; return bpm; }

  // --- FFT-based chroma for key/chords ---
  function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++){ w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); } return w; }
  function stftChroma(buf, winSize=4096, hop=2048){
    const sr=buf.sampleRate; const x=buf.getChannelData(0);
    const N=winSize; const H=hop; const numFrames = Math.max(1, Math.floor((x.length-N)/H)+1);
    const W = hann(N);
    // precompute FFT sine/cos (naive DFT for portability; OK at 4096 with hop 2048 for short slices)
    function dftMag(frame){
      const M=N/2;
      const mags=new Float32Array(M);
      for(let k=0;k<M;k++){
        let re=0, im=0;
        for(let n=0;n<N;n++){
          const ang = -2*Math.PI*k*n/N;
          const s = x[frame*H+n]*W[n];
          re += s*Math.cos(ang);
          im += s*Math.sin(ang);
        }
        mags[k]=Math.sqrt(re*re+im*im);
      }
      return mags;
    }
    // chroma bins (12)
    const chromaFrames=[];
    for(let f=0; f<numFrames; f++){
      const mags=dftMag(f);
      const chroma=new Float32Array(12);
      for(let k=1;k<mags.length;k++){
        const freq = k*sr/N;
        const midi = Math.round(69+12*Math.log2(freq/440));
        if (!isFinite(midi)) continue;
        const pc = ((midi%12)+12)%12;
        chroma[pc] += mags[k];
      }
      // normalize
      let s=0; for(let i=0;i<12;i++) s+=chroma[i];
      if(s>0){ for(let i=0;i<12;i++) chroma[i]/=s; }
      chromaFrames.push(chroma);
    }
    return {frames: chromaFrames, sr, hop: H/sr};
  }

  const keyProfiles = {
    major: [6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88],
    minor: [6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17]
  };

  const noteNames=["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
  function rotate(arr, n){ const a=arr.slice(); while(n-->0){ a.push(a.shift()); } return a; }

  function detectKeyFromChromaAvg(chromaAvg){
    // Compare to Krumhansl profiles for all 12 rotations
    function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
    function norm(a){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*a[i]; return Math.sqrt(s); }
    function cosSim(a,b){ return dot(a,b)/(norm(a)*norm(b)+1e-9); }
    let best = {mode:'major', root:0, score:-1};
    ['major','minor'].forEach(mode=>{
      for(let r=0;r<12;r++){
        const prof = rotate(keyProfiles[mode], r);
        const sc = cosSim(chromaAvg, prof);
        if(sc>best.score) best={mode, root:r, score:sc};
      }
    });
    return best; // {mode, root, score}
  }

  // Very simple chord templates (triads only) as pitch class sets
  const triads = {
    major:[0,4,7],
    minor:[0,3,7],
    dim:[0,3,6]
  };
  function chordName(rootPc, quality){
    const name = noteNames[rootPc];
    const qual = quality==='major'?'':quality==='minor'?'m':'dim';
    return name+qual;
  }

  function estimateChords(chromaFrames, secondsPerFrame, bpm, totalBars){
    // Aggregate one bar per chord: 4 beats/bar, seconds per beat = 60/bpm
    const spb = 60/(bpm||120);
    const secPerBar = 4*spb;
    const framesPerBar = Math.max(1, Math.round(secPerBar/secondsPerFrame));
    const bars = Math.min(totalBars, Math.floor(chromaFrames.length/framesPerBar));
    const chords=[];
    for(let b=0;b<bars;b++){
      const acc=new Float32Array(12);
      for(let f=0; f<framesPerBar; f++){
        const fr = chromaFrames[b*framesPerBar+f];
        for(let i=0;i<12;i++) acc[i]+=fr[i];
      }
      // pick root/quality maximizing template match
      let best={root:0, qual:'major', score:-1};
      for(let root=0; root<12; root++){
        ['major','minor','dim'].forEach(qual=>{
          const pcs = triads[qual].map(semi => (semi+root)%12);
          let s=0;
          pcs.forEach(pc => s+=acc[pc]);
          if(s>best.score) best={root, qual, score:s};
        });
      }
      chords.push({root:best.root, quality:best.qual, name:chordName(best.root, best.qual)});
    }
    return chords;
  }

  // ---------- BPM Analysis ----------
  q('#analyzeBtn').addEventListener('click', async ()=>{
    if(!refBuffer){ setFlow('Load a reference first (File, URL, or Demo).','warn'); return; }
    setFlow('Analyzing BPM…','busy');
    const ch = refBuffer.numberOfChannels>1 ? mixToMono(refBuffer) : refBuffer;
    const slice = centerSlice(ch, Math.min(30, ch.duration));
    const down = downsample(slice, 44100, 11025);
    const pre = preEmphasis(down, 0.97);
    const env = amplitudeEnvelope(pre, 1024, 512);
    const bpm = estimateBPM(env, 11025/512);
    bpmEl.value = Math.round(bpm);
    setFlow(`Detected BPM ~${Math.round(bpm)}`,'ok');
  });

  q('#detectKeyBtn').addEventListener('click', async ()=>{
    if(!refBuffer){ setFlow('Load a reference first.','warn'); return; }
    setFlow('Analyzing key & chords…','busy');
    const ch = refBuffer.numberOfChannels>1 ? mixToMono(refBuffer) : refBuffer;
    const slice = centerSlice(ch, Math.min(45, ch.duration)); // take up to 45s
    const chroma = stftChroma(slice, 4096, 2048);
    // Average chroma
    const avg = new Float32Array(12);
    chroma.frames.forEach(fr => { for(let i=0;i<12;i++) avg[i]+=fr[i]; });
    let s=0; for(let i=0;i<12;i++) s+=avg[i]; if(s>0) for(let i=0;i<12;i++) avg[i]/=s;
    const key = detectKeyFromChromaAvg(avg);
    const keyText = `${noteNames[key.root]} ${key.mode}`;
    q('#detectedKey').value = keyText;

    // Estimate per-bar chords if requested later
    const bpm = parseFloat(bpmEl.value)||110;
    const estChords = estimateChords(chroma.frames, chroma.hop, bpm, parseInt(q('#bars').value)||32);
    q('#useRefChords').checked = true;
    chordPreviewEl.textContent = estChords.map(c=>c.name).join(' | ');
    // Cache for generation
    window.__REF_FEATURES__ = {key, estChords};
    setFlow('Key & chords ready','ok');
  });

  // ---------- Generator ----------
  function noteToFreq(n){ return 440*Math.pow(2,(n-69)/12); }
  function midiForPc(pc, octave=4){ return 12*(octave+1)+pc; } // C4=60 when octave=4

  function buildChordsFromRef(estChords){
    // Transform chord list into timeline chord tones around C4 region
    return estChords.map(c=>{
      const pcs = c.quality==='major'? [0,4,7] : c.quality==='minor'? [0,3,7] : [0,3,6];
      const notes = pcs.map(semi => midiForPc((c.root+semi)%12, 4));
      return {name:c.name, notes};
    });
  }

  function defaultProgression(keyMode){
    const keyRoot = keyMode?.root ?? 0;
    const mode = keyMode?.mode ?? 'minor';
    const degrees = mode==='major'?[0,2,4,5,7,9,11]:[0,2,3,5,7,8,10];
    const progIdx = [[0,5,3,4],[0,4,5,3]][ mode==='major'?0:1 ];
    return progIdx.map(di => {
      const rootPc = (degrees[di] + keyRoot) % 12;
      const quality = (mode==='major' && (di===0||di===3||di===4)) || (mode!=='major' && (di===2)) ? 'major' : 'minor';
      const pcs = quality==='major'? [0,4,7] : [0,3,7];
      const notes = pcs.map(semi => midiForPc((rootPc+semi)%12, 4));
      const name = chordName(rootPc, quality);
      return {name, notes};
    });
  }

  function generateSong(){
    setFlow('Generating…','busy');
    const bpm=parseFloat(bpmEl.value)||110, bars=Math.max(4, Math.min(96, parseInt(q('#bars').value)||32));
    const spb=60/bpm, spbar=spb*4;

    // chord source: use reference-estimated chords if toggled, otherwise default progression based on detected key
    let chordsTimeline=[];
    const ref = window.__REF_FEATURES__;
    if (q('#useRefChords').checked && ref?.estChords?.length){
      const perBar = buildChordsFromRef(ref.estChords).slice(0, bars);
      for(let i=0;i<bars;i++){ const c=perBar[i%perBar.length]; chordsTimeline.push({time:i*spbar, notes:c.notes, name:c.name}); }
    } else {
      const base = defaultProgression(ref?.key);
      for(let i=0;i<bars;i++){ const c=base[i%base.length]; chordsTimeline.push({time:i*spbar, notes:c.notes, name:c.name}); }
    }
    chordPreviewEl.textContent = chordsTimeline.map(c=>c.name).join(' | ');

    // Build parts
    const bass=[], arp=[], lead=[], pad=[], drums=[];
    chordsTimeline.forEach((ch, idx)=>{
      const root = ch.notes[0]-24;
      bass.push({time:ch.time, midi:root, dur:spb*1.0, vel:.95});
      bass.push({time:ch.time+2*spb, midi:root, dur:spb*1.0, vel:.9});
      const seq=[0,1,2,1];
      for(let s=0;s<16;s++){ const tone=ch.notes[ seq[s%seq.length] ]; arp.push({time:ch.time + s*(spb/4), midi:tone+12, dur:spb/4*0.9, vel:.35}); }
      // lead: target chord tones with short approach
      const target = ch.notes[ (idx%3) ] + 12;
      lead.push({time:ch.time, midi:target, dur:spb*0.95, vel:.75});
      lead.push({time:ch.time+spb, midi:target+2, dur:spb*0.9, vel:.7});
      pad.push({time:ch.time, notes:ch.notes.map(n=>n+12), dur:spbar, vel:.28});
      // drums
      const swing=0.54; drums.push({time:ch.time, type:'kick'}); drums.push({time:ch.time+2*spb, type:'kick'}); drums.push({time:ch.time+1*spb, type:'snare'}); drums.push({time:ch.time+3*spb, type:'snare'});
      for(let e=0;e<8;e++){ const off=(e%2===1)?(spb/2)*(2*swing-1):0; drums.push({time:ch.time + e*(spb/2) + off, type:'hat'}); }
    });

    schedule={bpm,bars,chordsTimeline,bass,arp,lead,pad,drums,lengthSec: chordsTimeline.length*spbar};
    drawArrangement(bpm, bars);
    buildTrackUI();
    drawVisSkeleton(chordsTimeline.length*4);
    setFlow('Ready','ok');
  }

  function drawArrangement(bpm,bars){ arrangementEl.textContent = `Bars: ${bars}   @ ${Math.round(bpm)} BPM`; }
  function drawVisSkeleton(steps){ vis.innerHTML=''; const width=vis.clientWidth; const stepW=Math.max(2, Math.floor(width/steps));
    for(let i=0;i<steps;i++){ const bar=document.createElement('div'); bar.className='bar'; bar.style.left=(i*stepW)+'px'; bar.style.width=(stepW-1)+'px'; bar.style.height=(10+(i%4)*6)+'px'; bar.style.opacity=0.25+0.1*(i%4); vis.appendChild(bar);} }
  function buildTrackUI(){ tracksEl.innerHTML=''; const parts=[{id:'drums',name:'Drums'},{id:'bass',name:'Bass'},{id:'chords',name:'Chords'},{id:'arp',name:'Arp'},{id:'lead',name:'Lead'},{id:'pad',name:'Pad'}];
    parts.forEach(p=>{ const div=document.createElement('div'); div.className='track'; div.innerHTML=`
      <div><div>${p.name}</div><div class="small">Mute <input type="checkbox" id="mute_${p.id}" /></div></div>
      <div style="flex:1;margin:0 10px" class="meter"><div id="vu_${p.id}"></div></div>
      <div><label>Vol</label><input type="range" min="0" max="1" step="0.01" value="${p.id==='drums'?1.0:p.id==='lead'?0.9:0.85}" id="vol_${p.id}" /></div>`; tracksEl.appendChild(div); }); }

  // ---------- Playback chain with simple FX ----------
  function createFXBus(){
    const mix = audioCtx.createGain(); mix.gain.value = 1.0;
    const master = audioCtx.createGain(); master.gain.value = 0.95;

    // Stereo delay
    const delayL = audioCtx.createDelay(); delayL.delayTime.value = 0.3;
    const delayR = audioCtx.createDelay(); delayR.delayTime.value = 0.38;
    const fbL = audioCtx.createGain(); fbL.gain.value = 0.25;
    const fbR = audioCtx.createGain(); fbR.gain.value = 0.23;
    delayL.connect(fbL).connect(delayL);
    delayR.connect(fbR).connect(delayR);
    const panL = audioCtx.createStereoPanner(); panL.pan.value = -0.4;
    const panR = audioCtx.createStereoPanner(); panR.pan.value = 0.4;

    // Reverb (schroeder-ish)
    function makeComb(delayTime, feedback){
      const d = audioCtx.createDelay(); d.delayTime.value = delayTime;
      const g = audioCtx.createGain(); g.gain.value = feedback;
      d.connect(g).connect(d);
      const i = audioCtx.createGain(); i.gain.value = 1.0;
      i.connect(d);
      return {in:i, out:d};
    }
    const combs = [makeComb(0.0297,0.77), makeComb(0.0371,0.74), makeComb(0.0411,0.73), makeComb(0.0437,0.72)];
    const verbMix = audioCtx.createGain(); verbMix.gain.value = 0.18;
    const verbSum = audioCtx.createGain(); combs.forEach(c=> c.out.connect(verbSum)); verbSum.connect(verbMix);

    // Master comp
    const comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -20; comp.knee.value = 20; comp.ratio.value = 3.5; comp.attack.value = 0.005; comp.release.value = 0.25;

    // Wiring
    const fxSend = audioCtx.createGain(); fxSend.gain.value = 0.25;
    mix.connect(panL).connect(delayL).connect(comp);
    mix.connect(panR).connect(delayR).connect(comp);
    mix.connect(fxSend).connect(combs[0].in);
    mix.connect(fxSend).connect(combs[1].in);
    mix.connect(fxSend).connect(combs[2].in);
    mix.connect(fxSend).connect(combs[3].in);
    verbMix.connect(comp);
    comp.connect(master).connect(analyser).connect(audioCtx.destination);
    return {in:mix, out:master};
  }

  function playSong(){
    if(!schedule) generateSong();
    stopSong();
    setFlow('Playing…','busy');
    const startT=audioCtx.currentTime+0.05; const bus=createFXBus();
    const vols={}; ['drums','bass','chords','arp','lead','pad'].forEach(id=>{ const g=audioCtx.createGain(); g.gain.value=parseFloat(q('#vol_'+id).value); g.connect(bus.in); vols[id]=g; });

    // schedule synth voices
    schedule.drums.forEach(ev=>{ const t=startT+ev.time; if(q('#mute_drums').checked) return; if(ev.type==='kick') synthKick(t,vols.drums); else if(ev.type==='snare') synthSnare(t,vols.drums); else synthHat(t,vols.drums); });
    schedule.bass.forEach(n=>{ const t=startT+n.time; if(!q('#mute_bass').checked) synthMono(n.midi,n.dur,n.vel,t,vols.bass,'saw',500); });
    schedule.chordsTimeline.forEach(ch=>{ const t=startT+ch.time; if(!q('#mute_chords').checked) ch.notes.forEach((m,j)=> synthPad(m+12, (2.2), 0.22, t, vols.chords, 1800-(j*200))); });
    schedule.arp.forEach(n=>{ const t=startT+n.time; if(!q('#mute_arp').checked) synthMono(n.midi,n.dur,n.vel,t,vols.arp,'triangle',1400); });
    schedule.lead.forEach(n=>{ const t=startT+n.time; if(!q('#mute_lead').checked) synthLead(n.midi,n.dur,n.vel,t,vols.lead); });
    schedule.pad.forEach(p=>{ const t=startT+p.time; if(!q('#mute_pad').checked) p.notes.forEach(m=> synthPad(m,p.dur,p.vel,t,vols.pad,1600)); });

    currentGraph={bus};
    startVis();
    setTimeout(()=>{ stopSong(); setFlow('Stopped',''); }, (schedule.lengthSec+0.2)*1000);
  }

  function stopSong(){ if(currentGraph){ try{ currentGraph.out.disconnect(); }catch(e){} currentGraph=null; } stopVis(); }

  // Synths - improved subtractive
  function envParam(g, t, a=0.01, d=0.12, s=0.7, r=0.15, v=0.8){
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(v, t+a);
    g.gain.linearRampToValueAtTime(v*s, t+a+d);
    g.gain.linearRampToValueAtTime(0.0001, t+a+d+r);
  }
  function synthKick(t,dest){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(150,t); o.frequency.exponentialRampToValueAtTime(42,t+0.12);
    g.gain.setValueAtTime(1,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.22); o.connect(g).connect(dest); o.start(t); o.stop(t+0.24); }
  function synthSnare(t,dest){ const n=audioCtx.createBuffer(1,audioCtx.sampleRate*0.25,audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.6); }
    const s=audioCtx.createBufferSource(); s.buffer=n; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1850; bp.Q.value=0.6; const g=audioCtx.createGain(); envParam(g,t,0.001,0.12,0.0,0.12,0.8);
    s.connect(bp).connect(g).connect(dest); s.start(t); s.stop(t+0.25); }
  function synthHat(t,dest){ const n=audioCtx.createBuffer(1,audioCtx.sampleRate*0.12,audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1); }
    const s=audioCtx.createBufferSource(); s.buffer=n; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=9000; hp.Q.value=0.8; const g=audioCtx.createGain(); envParam(g,t,0.001,0.05,0.0,0.05,0.35);
    s.connect(hp).connect(g).connect(dest); s.start(t); s.stop(t+0.12); }
  function synthMono(midi,dur,vel,t,dest,type='saw',cutoff=1000){
    const o1=audioCtx.createOscillator(); const o2=audioCtx.createOscillator(); o1.type=type; o2.type=type;
    const det=audioCtx.createGain(); const g=audioCtx.createGain(); const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(cutoff,t);
    o1.frequency.setValueAtTime( noteToFreq(midi)*0.997, t); o2.frequency.setValueAtTime( noteToFreq(midi)*1.003, t);
    det.gain.value = 0.002; // subtle FM-ish detune
    envParam(g,t,0.01,0.10,0.6,0.12,vel);
    o1.connect(f); o2.connect(f); f.connect(g).connect(dest);
    o1.start(t); o2.start(t); o1.stop(t+dur+0.2); o2.stop(t+dur+0.2);
  }
  function synthLead(midi,dur,vel,t,dest){
    const o1=audioCtx.createOscillator(); const o2=audioCtx.createOscillator(); o1.type='saw'; o2.type='triangle';
    const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(2200,t);
    const g=audioCtx.createGain(); envParam(g,t,0.008,0.12,0.55,0.12,vel);
    o1.frequency.setValueAtTime(noteToFreq(midi)*0.999,t); o2.frequency.setValueAtTime(noteToFreq(midi)*1.001,t);
    o1.connect(f).connect(g).connect(dest); o2.connect(f);
    o1.start(t); o2.start(t); o1.stop(t+dur+0.2); o2.stop(t+dur+0.2);
  }
  function synthPad(midi,dur,vel,t,dest,cutoff=1600){
    const o=audioCtx.createOscillator(); o.type='saw';
    const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(cutoff,t);
    const g=audioCtx.createGain();
    g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(vel, t+0.35); g.gain.linearRampToValueAtTime(vel*0.85, t+dur*0.8); g.gain.linearRampToValueAtTime(0.0001, t+dur+0.45);
    o.frequency.setValueAtTime(noteToFreq(midi), t);
    o.connect(f).connect(g).connect(dest);
    o.start(t); o.stop(t+dur+0.6);
  }

  // Visualization
  function startVis(){ stopVis(); const arr=new Uint8Array(analyser.frequencyBinCount); function loop(){ analyser.getByteTimeDomainData(arr);
      const bars=vis.children; if(bars.length){ const avg=arr.reduce((a,b)=>a+Math.abs(b-128),0)/arr.length; const h=Math.min(80, Math.max(6, avg*0.9));
      const idx=Math.floor(((audioCtx.currentTime%1)*bars.length)); for(let i=0;i<bars.length;i++){ const el=bars[i]; if(i===idx) el.style.height=h+'px'; el.style.opacity=0.2+0.6*((i%4)/4);} } visRAF=requestAnimationFrame(loop); }
    visRAF=requestAnimationFrame(loop); }
  function stopVis(){ if(visRAF) cancelAnimationFrame(visRAF); visRAF=null; }

  // Export (same arrangement, offline render with same synths)
  async function exportWav(){
    if(!schedule) generateSong();
    setFlow('Exporting…','busy');
    const sr=44100; const length=Math.ceil(schedule.lengthSec*sr)+sr;
    const off=new (window.OfflineAudioContext||window.webkitOfflineAudioContext)(2,length,sr); const bus=off.createGain(); bus.gain.value=0.95; bus.connect(off.destination);

    function connectVol(id){ const g=off.createGain(); g.gain.value=parseFloat(q('#vol_'+id).value)*(q('#mute_'+id).checked?0:1); g.connect(bus); return g; }
    const vols={drums:connectVol('drums'),bass:connectVol('bass'),chords:connectVol('chords'),arp:connectVol('arp'),lead:connectVol('lead'),pad:connectVol('pad')};

    function osc(type,freq,when,dur){ const o=off.createOscillator(); o.type=type; o.frequency.setValueAtTime(freq,when); o.start(when); o.stop(when+dur+0.01); return o; }
    function gain(){return off.createGain();} function biquad(type,freq){ const f=off.createBiquadFilter(); f.type=type; f.frequency.value=freq; return f; }
    function env(g, t, a=0.01, d=0.12, s=0.7, r=0.15, v=0.8){ g.gain.setValueAtTime(0.0001, t); g.gain.linearRampToValueAtTime(v, t+a); g.gain.linearRampToValueAtTime(v*s, t+a+d); g.gain.linearRampToValueAtTime(0.0001, t+a+d+r); }

    const startT=0.05;
    function o_kick(t,d){ const o=osc('sine',150,startT+t,0.24); const g=gain(); g.gain.setValueAtTime(1,startT+t); g.gain.exponentialRampToValueAtTime(0.0001,startT+t+0.22);
      o.frequency.setValueAtTime(150,startT+t); o.frequency.exponentialRampToValueAtTime(42,startT+t+0.12); o.connect(g).connect(d); }
    function o_snare(t,d){ const n=off.createBuffer(1, off.sampleRate*0.25, off.sampleRate); const data=n.getChannelData(0); for(let i=0;i<data.length;i++){ data[i]=(Math.random()*2-1)*Math.pow(1-i/data.length,1.6); }
      const s=off.createBufferSource(); s.buffer=n; const bp=biquad('bandpass',1850); const g=gain(); env(g,startT+t,0.001,0.12,0.0,0.12,0.8);
      s.connect(bp).connect(g).connect(d); s.start(startT+t); s.stop(startT+t+0.25); }
    function o_hat(t,d){ const n=off.createBuffer(1, off.sampleRate*0.12, off.sampleRate); const data=n.getChannelData(0); for(let i=0;i<data.length;i++){ data[i]=(Math.random()*2-1); }
      const s=off.createBufferSource(); s.buffer=n; const hp=biquad('highpass',9000); const g=gain(); env(g,startT+t,0.001,0.05,0.0,0.05,0.35);
      s.connect(hp).connect(g).connect(d); s.start(startT+t); s.stop(startT+t+0.12); }
    function o_mono(midi,dur,vel,t,d,type='saw',cutoff=1000){ const o1=osc(type, 440*Math.pow(2,(midi-69)/12)*0.999, startT+t, dur+0.2);
      const o2=osc(type, 440*Math.pow(2,(midi-69)/12)*1.001, startT+t, dur+0.2); const f=biquad('lowpass',cutoff); const g=gain(); env(g,startT+t,0.01,0.10,0.6,0.12,vel);
      o1.connect(f).connect(g).connect(d); o2.connect(f); }
    function o_pad(midi,dur,vel,t,d,cutoff=1600){ const o=osc('saw', 440*Math.pow(2,(midi-69)/12), startT+t, dur+0.6); const f=biquad('lowpass',cutoff); const g=gain();
      g.gain.setValueAtTime(0.0001,startT+t); g.gain.linearRampToValueAtTime(vel, startT+t+0.35); g.gain.linearRampToValueAtTime(vel*0.85, startT+t+dur*0.8); g.gain.linearRampToValueAtTime(0.0001, startT+t+dur+0.45);
      o.connect(f).connect(g).connect(d); }

    schedule.drums.forEach(ev=>{ if(ev.type==='kick') o_kick(ev.time, vols.drums); else if(ev.type==='snare') o_snare(ev.time, vols.drums); else o_hat(ev.time, vols.drums); });
    schedule.bass.forEach(n=> o_mono(n.midi,n.dur,n.vel,n.time,vols.bass,'saw',500));
    schedule.arp.forEach(n=> o_mono(n.midi,n.dur,n.vel,n.time,vols.arp,'triangle',1400));
    schedule.lead.forEach(n=> o_mono(n.midi,n.dur,n.vel,n.time,vols.lead,'saw',2000));
    schedule.pad.forEach(p=> p.notes.forEach(m=> o_pad(m,p.dur,p.vel,p.time,vols.pad,1600)));
    schedule.chordsTimeline.forEach(ch=> ch.notes.forEach(m=> o_pad(m+12, 2.2, 0.22, ch.time, vols.chords, 1700)));
    const rendered=await off.startRendering(); const wav=bufferToWav(rendered); downloadBlob(wav, 'Stratum_MelodyLab_Export.wav');
    setFlow('Export ready','ok');
  }

  function bufferToWav(buffer){ const numOfChan=buffer.numberOfChannels, length=buffer.length*numOfChan*2+44, bufferArr=new ArrayBuffer(length), view=new DataView(bufferArr),
    channels=[], sampleRate=buffer.sampleRate; let offset=0, pos=0;
    setUint32(0x46464952); setUint32(length-8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
    setUint32(sampleRate); setUint32(sampleRate*2*numOfChan); setUint16(numOfChan*2); setUint16(16); setUint32(0x61746164); setUint32(length-pos-4);
    for(let i=0;i<numOfChan;i++) channels.push(buffer.getChannelData(i));
    while(pos<length){ let sample=0; for(let i=0;i<numOfChan;i++){ const chan=channels[i]; sample=Math.max(-1,Math.min(1, chan[offset]||0)); setInt16(sample<0?sample*0x8000:sample*0x7FFF);} offset++; }
    return new Blob([view], {type:'audio/wav'});
    function setUint16(data){ view.setUint16(pos, data, true); pos+=2; } function setUint32(data){ view.setUint32(pos, data, true); pos+=4; } function setInt16(data){ view.setInt16(pos, data, true); pos+=2; } }
  function downloadBlob(blob, filename){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }

  // UI Handlers
  q('#startBtn').addEventListener('click', async ()=>{ await ensureAudio(); initUIAudioReady(); });
  q('#genBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); generateSong(); });
  q('#playBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); playSong(); });
  q('#stopBtn').addEventListener('click', ()=>{ stopSong(); setFlow('Stopped',''); });
  q('#exportBtn').addEventListener('click', async ()=>{ await ensureAudio(); if(!started) initUIAudioReady(); exportWav(); });
  q('#regenDrums').addEventListener('click', ()=>{ if(schedule) generateSong(); });
  q('#regenLead').addEventListener('click', ()=>{ if(schedule) generateSong(); });

  // Auto-generate on load
  window.addEventListener('load', ()=>{ generateSong(); });
})();
</script>
</body>
</html>
